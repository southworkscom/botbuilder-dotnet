# TODO: Write logs

steps:
- powershell: |
    if ("$(Build.Reason)" -eq 'PullRequest') {
      $updatedLibraries = @()
      $updatedFiles = $(git diff HEAD HEAD~ --name-only)
      foreach ($updatedFile in $updatedFiles) {
        $updatedLibrary = ''
        $libraries = ($env:BotBuilderDll).Split(",")
        foreach ($library in $libraries) {
          if($updatedFile -match ('*/' + $library + '/*')){
            $updatedLibraries.Add($library)
          }
        }
      }
    }
    "##vso[task.setVariable variable=BotBuilderUpdatedDll;isOutput=true]$updatedLibraries.Join(',')"
  displayName: 'Evaluate Updated Libraries'

- task: DownloadPipelineArtifact@1
  displayName: 'Download BotBuilderDLLs artifact'
  condition: ne(variables['BotBuilderUpdatedDll'], '')
  inputs:
    artifactName: 'BotBuilderDLLs-Debug-Windows-netcoreapp31'
    targetPath: '$(System.ArtifactsDirectory)/Artifacts'

- powershell: |
    $xml = "<?xml version=""1.0"" encoding=""utf-8""?>`n<packages>`n"

    $(BotBuilderUpdatedDll).Split(",") | ForEach-Object {
      $library = $_.Trim()
      $xml += "  <package id=""" + $library + """ version=""" + $env:ApiCompatVersion + """/>`n"
    }
    $xml += "</packages>"
    New-Item -Path $(System.DefaultWorkingDirectory) -Name "packages.config" -ItemType "file" -Value $xml -Force
    
    $xml
  displayName: 'Generate NuGet packages.config File'
  condition: ne(variables['BotBuilderUpdatedDll'], '')

- task: NuGetCommand@2
  displayName: 'NuGet Install Packages'
  condition: ne(variables['BotBuilderUpdatedDll'], '')
  inputs:
    command: custom
    arguments: 'install $(System.DefaultWorkingDirectory)\packages.config -OutputDirectory $(System.DefaultWorkingDirectory)\DownloadedNuGet'

- task: CmdLine@1
  displayName: 'Run dir'
  inputs:
    filename: dir
    arguments: '..\*.* /s'
  enabled: false

- powershell: |
    $libraries = ($(BotBuilderUpdatedDll) -replace ",", ".dll ") + ".dll"

    Write-Host "##vso[task.setvariable variable=librariesToCompare]$libraries"

    $path = "DownloadedNuGet\**\lib\netstandard2.0\*"

    If (!(Test-Path "LibrariesToCompare\")) {
      New-Item -Path "LibrariesToCompare\" -ItemType Directory
    }

    Copy-Item -Path $path -Destination "LibrariesToCompare\" -Recurse -Force

  displayName: 'Prepare Nuget Libraries to Binary Compare'
  condition: ne(variables['BotBuilderUpdatedDll'], '')

- task: CmdLine@1
  displayName: 'NuGet LibrariesToCompare Folder'
  condition: ne(variables['BotBuilderUpdatedDll'], '')
  inputs:
    filename: dir
    arguments: 'LibrariesToCompare\*.* /s'

- task: SOUTHWORKS.binaries-comparer.custom-build-release-task.binaries-comparer@0
  displayName: 'Compare Binaries'
  condition: ne(variables['BotBuilderUpdatedDll'], '')
  inputs:
    contractsRootFolder: 'LibrariesToCompare\'
    contractsFileName: '$(librariesToCompare)'
    implFolder: '$(System.ArtifactsDirectory)/Artifacts'
    failOnIssue: true
    resolveFx: false
    generateLog: true
    outputFilename: 'CompatResults.txt'
    outputFolder: '$(Build.ArtifactStagingDirectory)'
    useBaseline: false

- powershell: |
    $FilePath = "$(Build.ArtifactStagingDirectory)\"
    $FileName = "CompatResults.txt"

    $FileFullPath = $FilePath + $FileName
    $FileContent = @(Get-Content $FileFullPath)

    $result = ''
    $failed = $FALSE;

    ForEach ($line in $FileContent) {
      if ($line.StartsWith(':x:','CurrentCultureIgnoreCase')) {
        $failed = $TRUE
        $result += ":x: Found an incompatibility in at least one of all modified libraries:`n"
        $result += $line.Replace(":x: ", "") + "`n"
      } elseif ($failed) {
        $result += $line + "`n"
      } else {
        $firstIndex =  $line.IndexOf('**') + 2
        $lastIndex = $line.LastIndexOf('**')
        $libraries = $line.Substring($firstIndex, $lastIndex - $firstIndex).Split(' ')
        $result = ":heavy_check_mark: Found no incompatibilities for all modified libraries:`n"
        ForEach ($library in $libraries) {
          $libraryName = $library.Replace('.dll','') 
          $libraryName += " compared against [version $(ApiCompatVersion)](https://www.nuget.org/packages/$libraryName/$(ApiCompatVersion))"
          $result += '- ' + $libraryName + "`n"
        }
        break;
      }
    }
        


    Set-Content -Path $FileFullPath -Value $result
    $result
  displayName: 'Format CompatResults file'
  condition: and(succeededOrFailed(), ne(variables['BotBuilderUpdatedDll'], ''))

- task: SOUTHWORKS.github-pr-comment.custom-publish-comment-task.github-pr-comment@0
  displayName: 'Publish Compat Results to Github'
  inputs:
    userToken: '$(GitHubCommentApiKey)'
    bodyFilePath: '$(Build.ArtifactStagingDirectory)\'
    getSubFolders: true
  condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'), ne(variables['BotBuilderUpdatedDll'], ''))

- powershell: |
   # Check for string in the logs in the current DevOps pipeline run.
   # 
   # Note: The task immediately before this one may not get checked because its log may not yet be available.
   # Calls the Azure DevOps REST API.
   # Enable OAuth token access in the pipeline agent job for $(System.Accesstoken) to populate.

   $stringToCheckFor = '201 Created';
   
   Start-Sleep -Milliseconds 1000 # Give time for the last log to become available
   
   $collectionUri = "$env:SYSTEM_COLLECTIONURI";  # e.g. 'https://fuselabs.visualstudio.com'
   $teamProjectId = "$env:SYSTEM_TEAMPROJECTID";  # e.g. '86659c66-c9df-418a-a371-7de7aed35064' = SDK_v4
   
   # Get the current build ID.
   $buildId = "$env:BUILD_BUILDID";
   Write-Host 'Build ID = ' $buildId;
   
   # Get the log containers for the run.
   $uri = "$collectionUri/$teamProjectId/_apis/build/builds/$buildId/logs";
   
   $token = [System.Convert]::ToBase64String([System.Text.Encoding]::ASCII.GetBytes(":$(System.AccessToken)"));
   $header = @{authorization = "Basic $token"};
   
   $runLogContainers = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
   
   # Get the log from each log container.
   Write-Host 'Checking the logs:';
   $found = $false;
   foreach ($container in $runLogContainers.value) {
       $container.id;
       $uri = $container.url;
       $uri;
       $log = Invoke-RestMethod "$uri" -Method Get -ContentType "application/json" -Headers $header;
       
       # Search for our string.
       if (!$found -and $log.Contains($stringToCheckFor)) {
           $found = $true;
           $log;
           $mess = 'String "' + $stringToCheckFor + '" found in log #' + $container.id;
           Write-Host $mess;
       } else {
           ($log -split '\r?\n')[0] + '...';  # Print first line
       }
   }
   
   # If not found, throw an error.
   if (!$found) {
       Write-Host;
       $mess =  'Publish Compat Results failed. Is there a PR associated with this build? String "' + $stringToCheckFor + '" not found in the logs';
       throw $mess;
   }
   
  displayName: 'Verify Publish Compat Results success'
  continueOnError: true
  condition: and(succeededOrFailed(), eq(variables['Build.Reason'], 'PullRequest'), ne(variables['BotBuilderUpdatedDll'], ''))

- script: |
   cd ..
   dir /s
  displayName: 'Dir workspace'
  continueOnError: true
  condition: succeededOrFailed()


# - task: PublishBuildArtifacts@1
#   displayName: 'Publish CompatResults to artifact'
#   inputs:
#     ArtifactName: 'BotBuilderDLLs.CompatResults'

# - script: |
#    cd ..
#    dir /s
#   displayName: 'Dir workspace'
#   continueOnError: true
#   condition: succeededOrFailed()
